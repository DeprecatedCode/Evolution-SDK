<?php

/**
 * Action class that handles all the basic action and authentication stuff.
 *
 * @package default
 * @author David Boskovic
 */
class Action extends Format_Validation {

	/**
	 * Loads data from either the cache or the posted data.
	 *
	 * @var string
	 */
	public $data = array();
	public $_save_data = false;
	public $input_data = array();

	/**
	 * Response type. HTTP will redirect. JSON and XML will return their respective responses.
	 *
	 * @var string
	 */
	protected $type = 'http'; // http, return, json,xml
	
	/**
	 * Default success message.
	 *
	 * @var string
	 */
	protected $success_message = 'Success!';
	
	/**
	 * An array of messages generated by the validation methods.
	 *
	 * @var string
	 */
	protected $messages = array();
	
	/**
	 * Initialize this action.
	 *
	 * @param string $data 
	 * @author David Boskovic
	 */
	public function __construct($data = false) {
		if(isset($_REQUEST['_method'])) {
			$this->_load_data(e::$session->data('_actions', get_class($this)), $_POST, $_GET);
			//v($this);
			
			if($this->data['_success_url']) $this->_redirect_success_url = $this->data['_success_url'];
			if($this->data['_failure_url']) $this->_redirect_failure_url = $this->data['_failure_url'];
			
			// Run the custom method in simple mode
			$m = $_REQUEST['_method'];
			$this->$m();
			
			return $this->_close();
		}
		
		$this->_save_data = true;
		
		if(isset($_REQUEST['_reset'])) $this->reset();
		if(isset($data['_reset'])) $this->reset();
		# load the data to validate
		if(!$data) {
			$this->_load_data(e::$session->data('_actions', get_class($this)), $_POST, $_GET);
		}
		elseif(is_array($data)) {
			$this->input_data = $data;
			$this->type = false;
			$this->_load_data(e::$session->data('_actions', get_class($this)), $data);			
		}
		else {
			$this->_load_data(e::$session->data('_actions', get_class($this)));
		}
		unset($this->data['_reset']);
		
		if($this->data['_action_type']) $this->type = $this->data['_action_type'];
		if($this->data['_has_checked']) $this->_has_checked = $this->data['_has_checked'];
		if($data === true) $this->type = false;
		if($this->data['_success_url']) $this->_redirect_success_url = $this->data['_success_url'];
		if($this->data['_failure_url']) $this->_redirect_failure_url = $this->data['_failure_url'];
		if($this->data['_success_url'] == '@last_page') {
				if(e::$session->data('_last_page'))
					$this->_redirect_success_url = e::$session->data('_last_page');
				elseif(isset($_SERVER['HTTP_REFERER']))
					$this->_redirect_success_url = $_SERVER['HTTP_REFERER'];
		}
		if($this->data['_failure_url'] == '@last_page') {
				if(e::$session->data('_last_page'))
					$this->_redirect_failure_url = e::$session->data('_last_page');
				elseif(isset($_SERVER['HTTP_REFERER']))
					$this->_redirect_failure_url = $_SERVER['HTTP_REFERER'];
		}

		$this->_load_files();
		$this->init();
		$this->check_formats();
		$this->_dependency_checks();
		$r = $this->results();
		if($r['success'] && isset($this->data['_complete']) && $this->data['_complete'] > 0) $this->complete();
		unset($this->data['_complete']);
		$this->_close();
	}
	
	/**
	 * Make sure that some required variables are properly initialized.
	 *
	 * @return void
	 * @author David Boskovic
	 */
	protected function _dependency_checks() {
		if(strlen($this->_redirect_success_url) == 0) die('No success url provided.');
		if(strlen($this->_redirect_failure_url) == 0) die('No failure url provided.');
	}
	
	/**
	 * Run to close out the action after the validation methods are performed and we're ready to generate a response.
	 *
	 * @return void
	 * @author David Boskovic
	 */
	private function _close() {
		//var_dump($this->data);
		$this->data['_has_checked'] = $this->_has_checked;
		
		# If needed, save some data for later
		if($this->_save_data)
			e::$session->data['_actions'][get_class($this)] = $this->data;
		
		# handle redirecting and stuff if it's a url request
		if($this->type == 'url') {
			
		}
		
		# do nothing otherwise
		elseif($this->type == 'http') {
			
			$results = $this->results();
			//var_dump($results);
			# specifies data that will be available for one page load
			e::$session->flashdata('result_data', $results);
			
			if($this->data['_url'])
				e::redirect($this->data['_url']);
			
			if($results['success'] == true)
				e::redirect($this->_redirect_success_url);
			if($results['success'] == false)
				e::redirect($this->_redirect_failure_url);
		}
		
		# do nothing otherwise
		elseif($this->type == 'json') {
			echo json_encode($this->results());
		}
		
		# do nothing otherwise
		elseif($this->type == 'xml') {
			header("content-type: text/xml");
			echo ((string)$this->_to_xml($this->results(), 'result'));
		}
	}
	
	/**
	 * Get a formatted array of results to respond with.
	 *
	 * @return void
	 * @author David Boskovic
	 */
	protected function results() {
		$success = true;
		foreach($this->messages as $key => $result) {
			if($result['type'] == 'error') {
				$success = false;
			}
		}
		return array('success' => $success, 'messages' =>$this->messages, 'data' => $this->data);
	}
	
	/**
	 * Generate a message to display in the browser.
	 *
	 * @param string $type 
	 * @param string $msg 
	 * @return void
	 * @author David Boskovic
	 */
	protected function _message($type, $msg, $field = false) {
		$this->messages[] = array('field' => $field ? $field : '@', 'type' => $type, 'message' => $msg);
		if($type == 'error') return false;
		return true;
	}
	protected function init() {
		
	}
	
	protected function check_formats() {
		foreach($this->data as $key => $value) {
			if(($format = $this->_can_check_format($key))) {
				if(isset($this->_has_checked[$key]) && $this->_has_checked[$key] == true && !isset($_REQUEST[$key]) && !isset($this->input_data[$key])) continue;
				$result = $this->_check_format($value, $format);
				if($result !== true) {
					//var_dump($key);
					return isset($this->error_messages[$key]) ? $this->_message('error', $this->error_messages[$key]) : false;
				}
				else {
					//var_dump($key);
					$this->_has_checked[$key] = 1;
				}
			}
		}
		if(method_exists($this, '_validate_all')) $this->_validate_all();
	}
	
	protected function _load_data($var) {
		$args = func_get_args();
		foreach($args as $pd) {
			if(!is_array($pd) OR count($pd) == 0) continue;
			$this->data = array_merge($this->data, $pd);
		}
		return true;
	}
	
	protected function _load_files() {
		$pd = $_FILES;
		if(!is_array($pd) OR count($pd) == 0) return false;
		
		//foreach($pd as $key => $file) {
		//	var_dump($file);
		//}
	}
	/**
	 * The main function for converting to an XML document.
	 * Pass in a multi dimensional array and this recrusively loops through and builds up an XML document.
	 *
	 * @param array $data
	 * @param string $rootNodeName - what you want the root node to be - defaultsto data.
	 * @param SimpleXMLElement $xml - should only be used recursively
	 * @return string XML
	 */
	public function _to_xml($data, $rootNodeName = 'data', $xml=null)
	{
		// turn off compatibility mode as simple xml throws a wobbly if you don't.
		if (ini_get('zend.ze1_compatibility_mode') == 1)
		{
			ini_set ('zend.ze1_compatibility_mode', 0);
		}
 
		if ($xml == null)
		{
			$xml = simplexml_load_string("<?xml version='1.0' encoding='utf-8'?><$rootNodeName />");
		}
 
		// loop through the data passed in.
		foreach($data as $key => $value)
		{
			// no numeric keys in our xml please!
			if (is_numeric($key))
			{
				// make string key...
				$key = "unknownNode_". (string) $key;
			}
 
			// replace anything not alpha numeric
			$key = preg_replace('/[^a-z]/i', '', $key);
 
			// if there is another array found recrusively call this function
			if (is_array($value))
			{
				$node = $xml->addChild($key);
				// recrusive call.
				$this->_to_xml($value, $rootNodeName, $node);
			}
			else 
			{
				// add single node.
                                $value = htmlentities(is_bool($value) ? ($value ? '1' : '0') : $value);
				$xml->addChild($key,$value);
			}
 
		}
		// pass back as string. or simple xml object if you want!
		return $xml->asXML();
	}
	public function reset() {
		//var_dump('reset');die;
		$this->data = array();
		e::$session->data['_actions'][get_class($this)] = $this->data;
	}

}

class Format_Validation {
	protected $_format_regex = array(
		'email' => '/^([0-9a-zA-Z]([-\+.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$/'
	);
	protected $_has_checked = array();
	protected function _check_format($value, $format) {
		if(is_string($format)) {
			return $this->_check_regex($this->_format_regex[$format], $value);
		}
		elseif($format[0] == 'custom') {
			return call_user_func_array(array($this,'_validate_'.$format[1]),array($value));
		}
		elseif($format[0] == 'regex') {
			return $this->_check_regex($this->_format_regex[$format[1]], $value);
		}
		return false;
	}
	
	protected function _check_regex($regex, $value) {
		preg_match($regex, $value, $regs);
		if(count($regs) > 0) return true;
		return false;
	}
	protected function _can_check_format($key) {
		if(isset($this->_validate_configure[$key])) {
			$conf = $this->_validate_configure[$key];
			if(strpos($conf, '@default') === 0) $conf = trim(substr($conf, 8));
			if(strpos($conf, '@custom') === 0) $conf = trim(substr($conf, 7));
		}
		if(isset($this->_format_regex[$conf])) return array('regex', $conf);
		elseif(method_exists($this,'_validate_'.$conf)) return array('custom', $conf);
		return false;
	}
}